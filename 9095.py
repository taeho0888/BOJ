T = int(input())
test_cases = [int(input()) for _ in range(T)]

dp = [0]*12
dp[1], dp[2], dp[3] = 1, 2, 4

for i in range(4, 12):
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

for tc in test_cases:
    print(dp[tc])

# 입력 받은 테스트 케이스의 수(T)와 각 테스트 케이스의 값을 리스트에 저장합니다.

# dp 라는 이름의 리스트를 선언하고, 인덱스 1, 2, 3에 해당하는 값을 각각 1, 2, 4로 초기화 합니다. 이는 각각의 값들을 1, 2, 3의 합으로 표현하는 경우의 수입니다.

# 인덱스 4부터 11까지, 각 i에 대하여 dp[i]는 dp[i-1], dp[i-2], dp[i-3]의 합이 됩니다. 이는 i를 1, 2, 3의 합으로 나타내는 방법의 수가 이전 세 수의 합과 같음을 의미합니다.

# 각 테스트 케이스에 대하여, dp에서 해당하는 인덱스의 값을 출력합니다. 이는 해당하는 정수를 1, 2, 3의 합으로 나타내는 방법의 수입니다.

# 마지막에 1을 더해 4를 만드는 방법: 이 경우는 3을 만드는 모든 방법에 1을 더하는 것과 같습니다. 따라서 dp[4]는 dp[3]을 포함하게 됩니다.

# 마지막에 2를 더해 4를 만드는 방법: 이 경우는 2를 만드는 모든 방법에 2를 더하는 것과 같습니다. 따라서 dp[4]는 dp[2]를 포함하게 됩니다.

# 마지막에 3을 더해 4를 만드는 방법: 이 경우는 1을 만드는 모든 방법에 3을 더하는 것과 같습니다. 따라서 dp[4]는 dp[1]을 포함하게 됩니다.

# 결국 dp[4]는 dp[3], dp[2], dp[1]의 합과 같게 됩니다. 이를 일반화하면, 어떤 수 n을 만드는 방법은 n-1, n-2, n-3을 만드는 방법들에 각각 1, 2, 3을 더한 것과 같습니다.

# 따라서 dp[n]는 dp[n-1], dp[n-2], dp[n-3]의 합이 됩니다. 이렇게 현재 문제의 해답을 이전 문제의 해답들로부터 구하는 방법을 동적 계획법(dynamic programming)이라고 합니다.
